<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lumera: Find a song based on your mood</title>
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div class="lumera-header" id="lumeraHeader">
      <img src="assets/lumera.png" alt="Lumera Logo" class="lumera-logo" />
      <span class="lumera-title">Lumera</span>
    </div>
    <div class="skip-button" id="skipButton">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
        <path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z" />
      </svg>
      <span>skip</span>
    </div>
    <div class="mountain-background"></div>
    <div class="mountain-silhouette"></div>
    <div class="mountain-layer-2"></div>
    <div class="mountain-layer-3"></div>

    <div class="content-container">
      <!-- First text that fades in and out -->
      <h1 id="firstText" class="fade-text">LUMERA</h1>

      <!-- Second phase with dual text -->
      <div id="dualTextContainer" class="dual-text-container">
        <h2 id="firstDualText" class="dual-text">PICK A SONG YOU LIKE</h2>
        <h2 id="secondDualText" class="dual-text">PICK A MOOD YOU WANT</h2>
      </div>

      <!-- Tutorial page -->
      <div id="tutorialContainer" class="tutorial-container">
        <h2 class="tutorial-headline">How To Use</h2>
        <div class="tutorial-steps">
          <div class="tutorial-step">
            <div class="step-number">1</div>
            <div class="step-title"></div>
            <div class="step-description">
              pick a song you're into right now
            </div>
          </div>
          <div class="tutorial-step">
            <div class="step-number">2</div>
            <div class="step-title"></div>
            <div class="step-description">pick a mood you want</div>
          </div>
          <div class="tutorial-step">
            <div class="step-number">3</div>
            <div class="step-title"></div>
            <div class="step-description">submit & let the music take over</div>
          </div>
        </div>
        <button class="get-started-btn">get started</button>
      </div>

      <!-- Search bar -->
      <div id="searchContainer" class="search-container">
        <div class="search-helper-text">Find the tune. Flip the mood.</div>
        <div class="search-wrapper">
          <input
            type="text"
            class="glass-search-bar"
            placeholder="Search for songs here..."
            id="songSearch"
          />
          <div class="search-results" id="searchResults"></div>
        </div>

        <div class="dropdown-and-submit">
          <select class="glass-dropdown">
            <option disabled selected>Select a mood</option>
            <option value="happy">Happy</option>
            <option value="sad">Sad</option>
            <option value="energetic">Energetic</option>
            <option value="chill">Chill</option>
            <option value="romantic">Romantic</option>
            <option value="party">Party</option>
            <option value="focus">Focus</option>
            <option value="angry">Angry</option>
            <option value="nostalgic">Nostalgic</option>
            <option value="upbeat">Upbeat</option>
            <option value="mellow">Mellow</option>
            <option value="intense">Intense</option>
          </select>

          <button class="submit-btn">submit</button>
        </div>
      </div>
    </div>

    <div id="haPage" class="ha-page">
      <div class="ha-back-button" id="haBackButton">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
          <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" />
        </svg>
        <span>back</span>
      </div>
      <div class="ha-content" id="haContent">
        <!-- Song content will be populated here -->
      </div>
    </div>

    <script>
      // Animation sequence
      function startAnimationSequence() {
        const firstText = document.getElementById("firstText");
        const dualTextContainer = document.getElementById("dualTextContainer");
        const firstDualText = document.getElementById("firstDualText");
        const secondDualText = document.getElementById("secondDualText");
        const tutorialContainer = document.getElementById("tutorialContainer");
        const searchContainer = document.getElementById("searchContainer");
        const lumeraHeader = document.getElementById("lumeraHeader");
        const skipButton = document.getElementById("skipButton");

        let isSkipped = false; // Add this flag

        // Skip button functionality
        skipButton.addEventListener("click", () => {
          isSkipped = true; // Set flag to prevent all animations
          skipButton.style.display = "none";

          // Hide all animation elements immediately
          firstText.classList.remove("visible");
          dualTextContainer.classList.remove("visible");
          firstDualText.classList.remove("visible");
          secondDualText.classList.remove("visible");

          // Show tutorial and header immediately
          setTimeout(() => {
            tutorialContainer.classList.add("visible");
            lumeraHeader.classList.add("visible");
          }, 100);
        });

        // ðŸ”¥ TIMING CONTROLS - Only run if not skipped
        // Phase 1: Show "LUMERA"
        setTimeout(() => {
          if (!isSkipped) firstText.classList.add("visible");
        }, 500);

        // Phase 2: Hide first text and show dual text container
        setTimeout(() => {
          if (!isSkipped) firstText.classList.remove("visible");
        }, 3000);

        setTimeout(() => {
          if (!isSkipped) {
            dualTextContainer.classList.add("visible");
            firstDualText.classList.add("visible");
          }
        }, 4000);

        // Phase 3: Show second dual text below the first
        setTimeout(() => {
          if (!isSkipped) secondDualText.classList.add("visible");
        }, 6500);

        // Phase 4: Hide both dual texts and show tutorial
        setTimeout(() => {
          if (!isSkipped) {
            firstDualText.classList.remove("visible");
            secondDualText.classList.remove("visible");
            dualTextContainer.classList.remove("visible");
          }
        }, 8500);

        setTimeout(() => {
          if (!isSkipped) {
            tutorialContainer.classList.add("visible");
            lumeraHeader.classList.add("visible");
            skipButton.style.display = "none";
          }
        }, 10000);

        // Phase 5: Show search bar when "get started" is clicked
        const getStartedBtn = document.querySelector(".get-started-btn");
        getStartedBtn.addEventListener("click", () => {
          tutorialContainer.classList.remove("visible");
          setTimeout(() => {
            searchContainer.classList.add("visible");
          }, 600);
        });

        const submitBtn = document.querySelector(".submit-btn");
        getStartedBtn.addEventListener("click", () => {
          tutorialContainer.classList.remove("visible");
          setTimeout(() => {
            searchContainer.classList.add("visible");
          }, 600);
        });
      }

      // Spotify search functionality
      let searchTimeout;
      let selectedSong = null;

      function initializeSpotifySearch() {
        const searchBar = document.getElementById("songSearch");
        const searchResults = document.getElementById("searchResults");

        searchBar.addEventListener("input", function (e) {
          const query = e.target.value.trim();

          // Clear previous timeout
          clearTimeout(searchTimeout);

          if (query.length === 0) {
            searchResults.innerHTML = "";
            searchResults.style.display = "none";
            return;
          }

          // Debounce search requests
          searchTimeout = setTimeout(() => {
            searchSpotify(query);
          }, 300);
        });

        // Hide results when clicking outside
        document.addEventListener("click", function (e) {
          if (!e.target.closest(".search-wrapper")) {
            searchResults.style.display = "none";
          }
        });
      }

      async function searchSpotify(query) {
        const searchResults = document.getElementById("searchResults");

        try {
          const response = await fetch(
            `/api/search?q=${encodeURIComponent(query)}`
          );
          const data = await response.json();

          if (data.tracks && data.tracks.length > 0) {
            displaySearchResults(data.tracks);
          } else {
            searchResults.innerHTML =
              '<div class="no-results">No songs found</div>';
            searchResults.style.display = "block";
          }
        } catch (error) {
          console.error("Search error:", error);
          searchResults.innerHTML =
            '<div class="error-message">Search failed. Please try again.</div>';
          searchResults.style.display = "block";
        }
      }

      function displaySearchResults(tracks) {
        const searchResults = document.getElementById("searchResults");

        searchResults.innerHTML = tracks
          .map(
            (track) => `
      <div class="search-result-item" data-track-id="${
        track.id
      }" data-track-name="${track.name}" data-track-artists="${track.artists}">
        <div class="track-info">
          <div class="track-name">${track.name}</div>
          <div class="track-artist">${track.artists}</div>
        </div>
        ${
          track.image
            ? `<img src="${track.image}" alt="Album cover" class="track-image">`
            : ""
        }
      </div>
    `
          )
          .join("");

        searchResults.style.display = "block";

        // Add click handlers to results
        searchResults
          .querySelectorAll(".search-result-item")
          .forEach((item) => {
            item.addEventListener("click", function () {
              const trackName = this.dataset.trackName;
              const trackArtists = this.dataset.trackArtists;
              const trackId = this.dataset.trackId;

              // Update search bar with selected song
              document.getElementById(
                "songSearch"
              ).value = `${trackName} - ${trackArtists}`;

              // Store selected song data
              selectedSong = {
                id: trackId,
                name: trackName,
                artists: trackArtists,
                image: this.querySelector(".track-image")?.src || "",
                spotifyUrl: `https://open.spotify.com/track/${trackId}`,
              };

              // Hide results
              searchResults.style.display = "none";
            });
          });
      }

      // Start the animation when page loads
      window.addEventListener("load", () => {
        startAnimationSequence();
        initializeSpotifySearch();
      });

      // Remove focus from dropdown after selection
      const glassDropdown = document.querySelector(".glass-dropdown");
      if (glassDropdown) {
        glassDropdown.addEventListener("change", function (e) {
          e.target.blur();
        });
      }

      // Submit button fade to 'ha.' page
      const submitBtn = document.querySelector(".submit-btn");
      const searchContainer = document.getElementById("searchContainer");
      const haPage = document.getElementById("haPage");

      // Add mood selection variables
      let selectedMood = null;
      let currentRecommendation = null;
      let allRecommendations = [];
      let currentRecommendationIndex = 0;

      // Function to get mood selection from dropdown
      function getSelectedMood() {
        const moodDropdown = document.querySelector(".glass-dropdown");
        const selectedValue = moodDropdown ? moodDropdown.value : null;

        // Convert to proper case to match your server's expected format
        if (selectedValue && selectedValue !== "Select a mood") {
          return selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1);
        }

        return null;
      }

      // Function to get multiple recommendations from server
      async function getRecommendations(
        mood,
        selectedSongId = null,
        limit = 10
      ) {
        try {
          const response = await fetch("/api/recommend", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              mood: mood,
              selectedSongId: selectedSongId,
              limit: limit,
            }),
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get recommendations");
          }

          return data;
        } catch (error) {
          console.error("Error getting recommendations:", error);
          throw error;
        }
      }

      // Function to display recommendation
      function displayRecommendation(recommendation) {
        const haContent = document.getElementById("haContent");
        haContent.innerHTML = "";

        if (!recommendation || !recommendation.spotify) {
          haContent.innerHTML = `<div style="color:white;font-size:clamp(1rem, 2.5vw, 2rem);">No recommendation found. Try a different mood!</div>`;
          return;
        }

        const spotifyTrack = recommendation.spotify;

        // Create song display container
        const songDisplay = document.createElement("div");
        songDisplay.className = "song-display";

        // Create song image
        const songImage = document.createElement("img");
        songImage.src = spotifyTrack.image || "assets/default-album.png";
        songImage.alt = "Album cover";
        songImage.className = "song-image";

        // Create song info container
        const songInfo = document.createElement("div");
        songInfo.className = "song-info";

        // Create song title
        const songTitle = document.createElement("div");
        songTitle.className = "song-title";
        songTitle.textContent = spotifyTrack.name;

        // Create song artist
        const songArtist = document.createElement("div");
        songArtist.className = "song-artist";
        songArtist.textContent = spotifyTrack.artists;

        // Create album info
        const songAlbum = document.createElement("div");
        songAlbum.style.fontSize = "0.9em";
        songAlbum.style.opacity = "0.7";

        // Create button container
        const buttonContainer = document.createElement("div");
        buttonContainer.className = "button-container";

        // Create Spotify button
        const spotifyBtn = document.createElement("a");
        spotifyBtn.href = spotifyTrack.external_url;
        spotifyBtn.target = "_blank";
        spotifyBtn.className = "spotify-btn";

        // Create Spotify button content
        const spotifyIcon = document.createElement("img");
        spotifyIcon.src = "assets/spotify.svg";
        spotifyIcon.alt = "Spotify";
        spotifyIcon.width = 20;
        spotifyIcon.height = 20;

        const spotifyText = document.createElement("span");
        spotifyText.textContent = "open on spotify";

        spotifyBtn.appendChild(spotifyIcon);
        spotifyBtn.appendChild(spotifyText);

        // Create reroll button
        const rerollBtn = document.createElement("button");
        rerollBtn.className = "reroll-btn";
        rerollBtn.textContent = "reroll";

        // Add click handler for reroll button - updated to use batch
        rerollBtn.addEventListener("click", async function () {
          try {
            // Show loading state
            rerollBtn.textContent = "getting new song...";
            rerollBtn.disabled = true;

            // Check if we have more recommendations in the current batch
            if (currentRecommendationIndex + 1 < allRecommendations.length) {
              // Move to next recommendation in the batch
              currentRecommendationIndex++;
              currentRecommendation =
                allRecommendations[currentRecommendationIndex];
              displayRecommendation(currentRecommendation);
            } else {
              // We've exhausted the current batch, get a new batch
              const newRecommendationsData = await getRecommendations(
                selectedMood,
                selectedSong?.id,
                10
              );

              if (
                newRecommendationsData.recommendations &&
                newRecommendationsData.recommendations.length > 0
              ) {
                // Update with new batch
                allRecommendations = newRecommendationsData.recommendations;
                currentRecommendationIndex = 0;
                currentRecommendation =
                  allRecommendations[currentRecommendationIndex];
                displayRecommendation(currentRecommendation);
              } else {
                throw new Error("No new recommendations found");
              }
            }
          } catch (error) {
            console.error("Reroll error:", error);
            rerollBtn.textContent = "try again";
            rerollBtn.disabled = false;
            // You might want to show an error message to the user
          }
        });

        // Create preview button (if preview URL is available)
        if (spotifyTrack.preview_url) {
          const previewBtn = document.createElement("button");
          previewBtn.className = "preview-btn";
          previewBtn.textContent = "preview";

          let audio = null;
          previewBtn.addEventListener("click", function () {
            if (audio && !audio.paused) {
              audio.pause();
              previewBtn.textContent = "preview";
            } else {
              if (audio) {
                audio.pause();
              }
              audio = new Audio(spotifyTrack.preview_url);
              audio.play();
              previewBtn.textContent = "stop";

              audio.onended = function () {
                previewBtn.textContent = "preview";
              };
            }
          });

          buttonContainer.appendChild(previewBtn);
        }

        // Append elements
        buttonContainer.appendChild(spotifyBtn);
        buttonContainer.appendChild(rerollBtn);

        songInfo.appendChild(songTitle);
        songInfo.appendChild(songArtist);
        // Note: moodScore was referenced but not defined in original code
        // songInfo.appendChild(moodScore);
        songInfo.appendChild(buttonContainer);

        songDisplay.appendChild(songImage);
        songDisplay.appendChild(songInfo);

        haContent.appendChild(songDisplay);
      }

      // Main submit button handler
      if (submitBtn && searchContainer && haPage) {
        haPage.style.display = "none";
        haPage.style.opacity = 0;

        submitBtn.addEventListener("click", async function () {
          // Get selected mood
          selectedMood = getSelectedMood();

          if (!selectedMood) {
            alert("Please select a mood first!");
            return;
          }

          try {
            // Show loading state
            submitBtn.textContent = "finding your song...";
            submitBtn.disabled = true;

            // Get multiple recommendations from server
            const recommendationsData = await getRecommendations(
              selectedMood,
              selectedSong?.id,
              10
            );

            if (
              recommendationsData.recommendations &&
              recommendationsData.recommendations.length > 0
            ) {
              allRecommendations = recommendationsData.recommendations;
              currentRecommendationIndex = 0;
              currentRecommendation =
                allRecommendations[currentRecommendationIndex];
              displayRecommendation(currentRecommendation);

              // Transition to results page
              searchContainer.style.transition = "opacity 0.7s";
              searchContainer.style.opacity = 0;

              setTimeout(() => {
                searchContainer.style.display = "none";
                haPage.style.display = "flex";
                setTimeout(() => {
                  haPage.style.opacity = 1;
                }, 50);
              }, 700);
            } else {
              throw new Error("No recommendations found");
            }
          } catch (error) {
            console.error("Submit error:", error);
            alert("Failed to get recommendations. Please try again!");
          } finally {
            // Reset button state
            submitBtn.textContent = "submit";
            submitBtn.disabled = false;
          }
        });
      }

      // Add dropdown change handler
      document.addEventListener("DOMContentLoaded", function () {
        // Add event listener to dropdown
        const moodDropdown = document.querySelector(".glass-dropdown");
        if (moodDropdown) {
          moodDropdown.addEventListener("change", function () {
            selectedMood = getSelectedMood();
          });
        }
      });

      // Helper function to go back to search (you can add a back button)
      function goBackToSearch() {
        haPage.style.transition = "opacity 0.7s";
        haPage.style.opacity = 0;

        setTimeout(() => {
          haPage.style.display = "none";
          searchContainer.style.display = "block";
          setTimeout(() => {
            searchContainer.style.opacity = 1;
          }, 50);
        }, 700);
      }

      // Add back button functionality
      const haBackButton = document.getElementById("haBackButton");
      if (haBackButton) {
        haBackButton.addEventListener("click", function () {
          haPage.style.transition = "opacity 0.7s";
          haPage.style.opacity = 0;
          setTimeout(() => {
            haPage.style.display = "none";
            searchContainer.style.display = "block";
            setTimeout(() => {
              searchContainer.style.opacity = 1;
            }, 50);
          }, 700);
        });
      }
    </script>
  </body>
</html>
